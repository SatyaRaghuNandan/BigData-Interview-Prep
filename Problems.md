27 Coding Interview Patterns to crack Interviews at your Dream Companies:

1. Two Pointers

2. Prefix Sums

3. Sliding Window

4. Kadane’s Algorithm

5. Find Number of Subarrays

6. Fast and Slow Pointers

7. Depth-First Search (DFS)

8. Breadth-First Search (BFS)

9. Matrix Traversal

10. Adjacency List BFS / DFS

11. Two Heaps

12. Modified Binary Search

13. Topological Sort

14. Top K Elements

15. Linked List Reversal

16. Permutations

17. Combinations

18. Tree Maze (Backtracking)

19. Longest Common Subsequence

20. Monotonic Stack

21. Memoization

22. Tabulation

23. Multi-Source BFS

24. Merge Intervals

25. Trie-Based Word Search

26. Greedy Algorithms

27. Union-Find (Disjoint Set Union - DSU)


I have taken more than 50+ System Design Interviews in my 20 years of career.

Here are the 30 System Design lessons I want to give you:

- Design clear & secure APIs
- Use auto scaling for traffic spikes
- Index databases to optimize reads
- Assume failures. Make it fault-tolerant
- Partition and shard data for large datasets
- Shard SQL databases for horizontal scaling
- Use CDNs to reduce latency for global users
- Use websockets for real-time communication
- Use write-through cache for write-heavy apps
- Use an API gateway for multiple microservices
- Use microservices over monoliths for scalability
- Denormalize databases for read-heavy workloads
- Use SQL for structured data and ACID transactions
- Use load balancers for traffic distribution and availability
- Implement data replication and redundancy for fault tolerance
- Clarify functional and non-functional requirements before designing
- Add functionality only when needed. Avoid over-engineering
- Use rate limiting to prevent overload and DOS attacks
- Use heartbeats/health checks for failure detection
- Use the circuit breaker pattern to prevent failures
- Use message queues for async communication
- Make operations idempotent to simplify retries
- Use read-through cache for read-heavy apps
- Use event-driven architecture for decoupling
- Use async processing for non-urgent tasks
- Use data lakes or warehouses for analytics
- Prefer horizontal scaling for scalability
- No perfect solution—only trade-offs
- Use NoSQL for unstructured data
- Use blob storage for media files

Follow me Raman Walia for more content on Interview Prep, System Design and Software Engineering
